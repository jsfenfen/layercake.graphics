{"main":{"title":"main.js","contents":"import LayerCake from 'layercake';\nimport fruit from './data/fruit.js';\nimport MultiLine from './components/MultiLine.html';\nimport AxisX from './components/AxisX.html';\nimport AxisY from './components/AxisY.html';\nimport LineLabels from './components/LineLabels.html';\nimport Tooltip from './components/Tooltip.html';\n\nconst fruitLong = Object.keys(fruit[0]).map(key => {\n  if (key === 'month') return null;\n  return {\n    key,\n    values: fruit.map(d => {\n      return { key, month: d.month, value: d[key] };\n    })\n  };\n}).filter(d => d);\n\nconst monthNames = ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May', 'June', 'July', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec.'];\n\nfunction formatXTick (d) {\n  const date = new Date(d);\n  return `${monthNames[date.getMonth()]} ${date.getDate()}`;\n}\n\nfunction formatYTick (d) {\n  if (d > 999) {\n    return d / 1000 + 'k';\n  }\n  return d;\n}\n\n// Make a flat array of the `values` of our nested series\n// we can pluck the `value` field from each item in the array to measure extents\nconst flatten = data => data.reduce((store, group) => store.concat(group.values), []);\n\nconst myCake = new LayerCake({\n  padding: { top: 7, right: 10, bottom: 20, left: 25 },\n  x: 'month',\n  y: 'value',\n  flatData: flatten(fruitLong),\n  yDomain: [0, null],\n  data: fruitLong,\n  target: document.getElementById('my-chart'),\n  fruit_: fruit\n})\n  .svgLayers([\n    { component: AxisX, opts: { gridlines: false, tickNumber: 3, formatTick: formatXTick } },\n    { component: AxisY, opts: { formatTick: formatYTick } },\n    { component: MultiLine, opts: {} }\n  ])\n  .htmlLayers([\n    { component: LineLabels, opts: {} },\n    { component: Tooltip, opts: {} }\n  ]);\n\nmyCake.render();"},"htmlExtras":"","components":[{"title":"./components/MultiLine.html","contents":"{#each sorted as group}\n  <path class='path-line' d='{path(group.values)}' stroke=\"{stroke(group.key)}\"></path>\n{/each}\n<style>\n  .path-line {\n    fill: none;\n    stroke-linejoin: round;\n    stroke-linecap: round;\n    stroke-width: 3px;\n  }\n</style>\n\n<script>\nconst colors = {\n  apples: '#ffe4b8',\n  bananas: '#ffb3c0',\n  cherries: '#ff7ac7',\n  dates: '#ff00cc'\n};\nexport default {\n  namespace: 'svg',\n  computed: {\n    // Sort the lines by the highest point on hover, as requested by @veltman\n    sorted: ({ $data, $highest_ }) => {\n      if ($highest_) {\n        return $data.filter(d => d.key !== $highest_).concat($data.filter(d => d.key === $highest_));\n      }\n      return $data;\n    },\n    path: ({ $xGet, $yGet }) => {\n      return values => {\n        return 'M' + values\n          .map(function (d, i) {\n            return $xGet(d) + ',' + $yGet(d);\n          })\n          .join('L');\n      };\n    }\n  },\n  helpers: {\n    stroke: key => colors[key]\n  }\n};\n</script>"},{"title":"./components/AxisX.html","contents":"<g class='axis x-axis'>\n  {#each ticks as tick, i}\n    <g class='tick tick-{ tick }' transform='translate({$xScale(tick)},{$yScale.range()[0]})'>\n      {#if opts.gridlines !== false}\n        <line y1='{$height * -1}' y2='0' x1='0' x2='0'></line>\n      {/if}\n      <text y='16' text-anchor='{textAnchor(i)}'>{opts.formatTick ? opts.formatTick(tick) : tick}</text>\n    </g>\n  {/each}\n  {#if opts.baseline === true}\n    <line class=\"baseline\" y1='{$height + 0.5}' y2='{$height + 0.5}' x1='0' x2='{$width}'></line>\n  {/if}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  line,\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .baseline {\n    stroke-dasharray: 0;\n  }\n</style>\n\n<script>\nexport default {\n  namespace: 'svg',\n  computed: {\n    ticks: ({ $xScale, opts }) => {\n      return $xScale.ticks(opts.ticks || opts.tickNumber);\n    },\n    textAnchor: ({ ticks, opts }) => {\n      return function (i) {\n        if (opts.snapTicks === true) {\n          if (i === 0) {\n            return 'start';\n          }\n          if (i === ticks.length - 1) {\n            return 'end';\n          }\n        }\n        return 'middle';\n      };\n    }\n  }\n};\n</script>"},{"title":"./components/AxisY.html","contents":"<g class='axis y-axis' transform='translate(-{$padding.left}, 0)'>\n  {#each $yScale.ticks(opts.ticks || opts.tickNumber || 5) as tick, i}\n    <g class='tick tick-{tick}' transform='translate(0, {$yScale(tick)})'>\n      {#if opts.gridlines !== false}\n        <line x2='100%'></line>\n      {/if}\n      <text y='-4'>{opts.formatTick ? opts.formatTick(tick) : tick}</text>\n    </g>\n  {/each}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n    text-anchor: start;\n  }\n\n  .tick.tick-0 line {\n    stroke-dasharray: 0;\n  }\n</style>\n\n<script>\nexport default {\n  namespace: 'svg'\n};\n</script>"},{"title":"./components/LineLabels.html","contents":"{#each $data as group}\n  <div class=\"label\" style=\"top:{top(group.values)}px;left:{left(group.values)}px;\">{pretty(group.key)}</div>\n{/each}\n\n<style>\n  .label {\n    position: absolute;\n    transform: translate(-100%, -100%)translateY(1px);\n    font-size: 13px;\n  }\n</style>\n\n<script>\nimport * as _ from 'underscore';\n\nexport default {\n  computed: {\n    left: ({ $xGet, $x }) => {\n      return (values) => {\n        // Don't assume this is sorted\n        const max = _.max(values, d => $x(d));\n        return $xGet(max);\n      };\n    },\n    top: ({ $yGet, $x }) => {\n      return (values) => {\n        // Don't assume this is sorted\n        const max = _.max(values, d => $x(d));\n        return $yGet(max);\n      };\n    }\n  },\n  helpers: {\n    pretty: (val) => {\n      return val.charAt(0).toUpperCase() + val.slice(1, val.length);\n    }\n  }\n};\n</script>"},{"title":"./components/Tooltip.html","contents":"<div ref:bg on:mousemove=\"mousemove(event)\" on:mouseout=\"mouseout()\">\n</div>\n<div ref:tooltip style=\"display: { visible ? 'block' : 'none' };top:{top}px;left:{left}px\">{@html contents}</div>\n\n<style>\n  ref:bg,\n  ref:tooltip {\n    position: absolute;\n  }\n\n  ref:bg {\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n\n  ref:tooltip {\n    font-size: 13px;\n    pointer-events: none;\n    width: 150px;\n    border: 1px solid #ccc;\n    background: #fff;\n    transform: translate(-50%, -100%);\n    display: none;\n    padding: 5px;\n  }\n</style>\n\n<script>\nimport { quadtree } from 'd3-quadtree';\nconst monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\n\nfunction capitalize (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1, str.length);\n}\n\nfunction addCommas (num) {\n  const parts = String(num).split('.');\n  parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n  return parts.join('.');\n}\n\nexport default {\n  data () {\n    return {\n      top: 0,\n      left: 0,\n      visible: false,\n      contents: ''\n    };\n  },\n  computed: {\n    finder: ({ $xGet, $width, $height, $fruit_ }) => {\n      return quadtree()\n        .extent([[-1, -1], [$width + 1, $height + 1]])\n        .x($xGet)\n        .y($xGet)\n        .addAll($fruit_);\n    }\n  },\n  methods: {\n    mousemove (e) {\n      const { finder } = this.get();\n      const found = finder.find(e.layerX, e.layerX, 300);\n\n      if (found) {\n        this.setContents(found);\n        this.set({ visible: true, top: e.layerY - 5, left: e.layerX });\n      } else {\n        this.set({ visible: false });\n      }\n    },\n\n    mouseout () {\n      this.set({ visible: false });\n    },\n\n    setContents (result) {\n      const rows = Object.keys(result).filter(d => d !== 'month').map(key => {\n        return {\n          key,\n          value: result[key]\n        };\n      }).sort((a, b) => b.value - a.value);\n\n      const contents = `\n        <div style=\"font-weight: bold;\">${monthNames[result.month.getMonth()]} ${result.month.getDate()}</div>\n        ${rows.map(row => `<div><span style=\"color: #999; width: 65px;display:inline-block;\">${capitalize(row.key)}:</span> ${addCommas(row.value)}</div>`).join('')}\n      `;\n\n      this.store.set({ highest_: rows[0].key });\n      this.set({ contents });\n    }\n  }\n};\n</script>"}],"modules":[{"title":"./data/fruit.js","contents":"/* --------------------------------------------\n *\n * Example data for stacked charts\n * from D3 documentation\n * Adapted from https://github.com/d3/d3-shape/blob/master/README.md#stack\n *\n * --------------------------------------------\n */\nexport default [\n  {month: new Date(2015, 3, 1), apples: 3840, bananas: 1920, cherries: 960, dates: 400},\n  {month: new Date(2015, 2, 1), apples: 1600, bananas: 1440, cherries: 960, dates: 400},\n  {month: new Date(2015, 1, 1), apples: 640, bananas: 960, cherries: 640, dates: 400},\n  {month: new Date(2015, 0, 1), apples: 320, bananas: 480, cherries: 640, dates: 400}\n];"}],"componentModules":[],"dek":"A fancy example with a quadtree tooltip lines that change their z-position based on whichever has the highest value at that hover position.\n"}