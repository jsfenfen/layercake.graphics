{"main":{"title":"main.js","contents":"import LayerCake from 'layercake';\nimport { scaleBand } from 'd3-scale';\nimport fruit from './data/fruitOrdinal.js';\nimport ClevelandDotPlot from './components/ClevelandDotPlot.html';\nimport AxisX from './components/AxisX.html';\nimport AxisY from './components/AxisYScaleBand.html';\n\nconst colors = ['#f0c', '#00bbff', '#00e047', '#ffdd57'];\n\nconst myCake = new LayerCake({\n  padding: { right: 10, bottom: 20, left: 30 },\n  x: ['apples', 'bananas', 'cherries', 'dates'],\n  y: 'year',\n  yScale: scaleBand().paddingInner([0.05]).round(true),\n  yDomain: ['2016', '2017', '2018', '2019'],\n  xDomain: [0, null],\n  xPadding: [10, 0],\n  data: fruit,\n  target: document.getElementById('my-chart')\n})\n  .svgLayers([\n    { component: AxisX, opts: {} },\n    { component: AxisY, opts: { gridlines: false } },\n    { component: ClevelandDotPlot, opts: { colors } }\n  ]);\n\nmyCake.render();"},"htmlExtras":"","components":[{"title":"./components/ClevelandDotPlot.html","contents":"{#each $data as row}\n  <g>\n    <line x1=\"{Math.min(...$xGet(row))}\" y1=\"{$yGet(row) + midHeight}\" x2=\"{Math.max(...$xGet(row))}\" y2=\"{$yGet(row) + midHeight}\"></line>\n\n    {#each $xGet(row) as circleX, i}\n      <circle cx=\"{circleX}\" cy=\"{$yGet(row) + midHeight}\" r=\"5\" fill=\"{colorScale($originalSettings.x[i])}\"></circle>\n    {/each}\n  </g>\n{/each}\n\n<style>\n  line {\n    stroke-width: 1px;\n    stroke: #000;\n  }\n  circle {\n    stroke: #000;\n    stroke-width: 1px;\n  }\n</style>\n\n<script>\nimport { scaleOrdinal } from 'd3-scale';\n\nexport default {\n  namespace: 'svg',\n  computed: {\n    midHeight: ({ $yScale }) => {\n      return $yScale.bandwidth() / 2;\n    },\n    colorScale: ({ $originalSettings, opts }) => {\n      return scaleOrdinal()\n        .domain($originalSettings.x)\n        .range(opts.colors);\n    }\n  }\n};\n</script>"},{"title":"./components/AxisX.html","contents":"<g class='axis x-axis'>\n  {#each ticks as tick, i}\n    <g class='tick tick-{ tick }' transform='translate({$xScale(tick)},{$yScale.range()[0]})'>\n      {#if opts.gridlines !== false}\n        <line y1='{$height * -1}' y2='0' x1='0' x2='0'></line>\n      {/if}\n      <text y='16' text-anchor='{textAnchor(i)}'>{opts.formatTick ? opts.formatTick(tick) : tick}</text>\n    </g>\n  {/each}\n  {#if opts.baseline === true}\n    <line class=\"baseline\" y1='{$height + 0.5}' y2='{$height + 0.5}' x1='0' x2='{$width}'></line>\n  {/if}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  line,\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .baseline {\n    stroke-dasharray: 0;\n  }\n</style>\n\n<script>\nexport default {\n  namespace: 'svg',\n  computed: {\n    ticks: ({ $xScale, opts }) => {\n      return opts.ticks || $xScale.ticks(opts.tickNumber);\n    },\n    textAnchor: ({ ticks, opts }) => {\n      return function (i) {\n        if (opts.snapTicks === true) {\n          if (i === 0) {\n            return 'start';\n          }\n          if (i === ticks.length - 1) {\n            return 'end';\n          }\n        }\n        return 'middle';\n      };\n    }\n  }\n};\n</script>"},{"title":"./components/AxisYScaleBand.html","contents":"<g class='axis y-axis'>\n  {#each $yScale.domain() as tick}\n    <g class='tick tick-{ tick }' transform='translate({$xScale.range()[0]}, {$yScale(tick)})'>\n      {#if opts.gridlines !== false}\n        <line x2='100%' y1=\"{halfBandwidth}\" y2=\"{halfBandwidth}\"></line>\n      {/if}\n      <text y='{4 + (halfBandwidth)}' x=\"-5\">{opts.formatTick ? opts.formatTick(tick) : tick}</text>\n    </g>\n  {/each}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .tick.tick-0 line {\n    stroke-dasharray: 0;\n  }\n\n  .y-axis .tick text {\n    text-anchor: end;\n  }\n</style>\n\n<script>\nexport default {\n  namespace: 'svg',\n  computed: {\n    halfBandwidth: ({ $yScale }) => {\n      return $yScale.bandwidth() / 2;\n    }\n  }\n};\n</script>"}],"modules":[{"title":"./data/fruitOrdinal.js","contents":"/* --------------------------------------------\n *\n * Example data for stacked charts\n * from D3 documentation\n * Adapted from https://github.com/d3/d3-shape/blob/master/README.md#stack\n *\n * --------------------------------------------\n */\nexport default [\n  {year: '2019', apples: 3840, bananas: 1920, cherries: 960, dates: 400},\n  {year: '2018', apples: 1600, bananas: 1440, cherries: 960, dates: 400},\n  {year: '2017', apples: 820, bananas: 1000, cherries: 640, dates: 400},\n  {year: '2016', apples: 820, bananas: 560, cherries: 720, dates: 400}\n];"}],"componentModules":[],"dek":"You could create this kind of plot by reshaping your data into rows of containing `name`, `value` and `group` and plot it kind of like a scatter plot. But here's another way that keeps the data in its current form and takes advantage of Layer Cake's accessor shorthand. In `main.js`, we simply specify the names of the keys in each row that we want to plot and in the layer component, we call `$xGet(row)` and it maps our row into an array of pixel values.\n"}