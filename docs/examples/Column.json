{"main":{"title":"main.js","contents":"import LayerCake from 'layercake';\nimport { scaleBand } from 'd3-scale';\nimport groups from './data/groups.js';\nimport Column from './components/Column.html';\nimport AxisX from './components/AxisXScaleBand.html';\nimport AxisY from './components/AxisY.html';\nimport Annotations from './components/Annotations.html';\nimport Arrows from './components/Arrows.html';\nimport DefArrowhead from './components/DefArrowhead.html';\n\nconst annotations = [\n  {\n    text: 'Example text...',\n    top: '18%',\n    left: '30%',\n    arrows: [{\n      clockwise: false, // true or false, defaults to true\n      source: {\n        anchor: 'left-bottom', // can be `{left, middle, right},{top-middle-bottom}`\n        dx: -2,\n        dy: -7\n      },\n      target: {\n        x: '28%',\n        y: '75%'\n      }\n    },\n    {\n      source: {\n        anchor: 'right-bottom',\n        dy: -7,\n        dx: 5\n      },\n      target: {\n        x: '68%',\n        y: '48%'\n      }\n    }]\n  }\n];\n\nconst myCake = new LayerCake({\n  padding: { top: 0, right: 0, bottom: 20, left: 20 },\n  x: 'year',\n  y: 'value',\n  xScale: scaleBand().paddingInner([0.02]).round(true),\n  xDomain: ['1979', '1980', '1981', '1982', '1983'],\n  yDomain: [0, null],\n  data: groups,\n  target: document.getElementById('my-chart')\n})\n  .svgLayers([\n    { component: AxisX, opts: { gridlines: false } },\n    { component: AxisY, opts: { gridlines: false, ticks: 3 } },\n    { component: Column, opts: {} }\n  ])\n  .htmlLayers([\n    { component: Annotations, opts: { annotations } }\n  ])\n  .svgLayers([\n    { component: Arrows, opts: { annotations } }\n  ], { defs: DefArrowhead });\n\nmyCake.render();"},"htmlExtras":"","components":[{"title":"./components/Column.html","contents":"{#each $data as d, i}\n  <rect class='group-rect' data-id=\"{i}\" x=\"{x(d)}\" y=\"{y(d)}\" {width} height=\"{height(d)}\"\n  fill=\"{opts.fill || '#00e047'}\" stroke=\"{opts.stroke || ''}\" stroke-width=\"{opts['stroke-width'] || 0}\"></rect>\n{/each}\n\n<script>\nexport default {\n  namespace: 'svg',\n  computed: {\n    x: ({ $xGet }) => {\n      return (d) => {\n        return $xGet(d);\n      };\n    },\n    y: ({ $yGet }) => {\n      return (d) => {\n        return $yGet(d);\n      };\n    },\n    width: ({ $xScale }) => {\n      return $xScale.bandwidth();\n    },\n    height: ({ $height, $xScale, y }) => {\n      return (d) => {\n        return $height - y(d);\n      };\n    }\n  }\n};\n</script>"},{"title":"./components/AxisXScaleBand.html","contents":"<g class='axis x-axis'>\n  {#each $xScale.domain() as tick}\n    <g class='tick tick-{ tick }' transform='translate({$xScale(tick)},{$yScale.range()[0]})'>\n      {#if opts.gridlines !== false}\n        <line y1='{$height * -1}' y2='0' x1='0' x2='0'></line>\n      {/if}\n      <text y='16' x=\"{$xScale.bandwidth() / 2}\">{opts.formatTick ? opts.formatTick(tick) : tick}</text>\n    </g>\n  {/each}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n    text-anchor: start;\n  }\n\n  .tick.tick-0 line {\n    stroke-dasharray: 0;\n  }\n\n  .x-axis .tick text {\n    text-anchor: middle;\n  }\n</style>\n\n<script>\nexport default {\n  namespace: 'svg'\n};\n</script>"},{"title":"./components/AxisY.html","contents":"<g class='axis y-axis' transform='translate(-{$padding.left}, 0)'>\n  {#each $yScale.ticks(opts.tickNumber || 5) as tick, i}\n    <g class='tick tick-{tick}' transform='translate(0, {$yScale(tick)})'>\n      {#if opts.gridlines !== false}\n        <line x2='100%'></line>\n      {/if}\n      <text y='-4'>{opts.formatTick ? opts.formatTick(tick) : tick}</text>\n    </g>\n  {/each}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n    text-anchor: start;\n  }\n\n  .tick.tick-0 line {\n    stroke-dasharray: 0;\n  }\n</style>\n\n<script>\nexport default {\n  namespace: 'svg'\n};\n</script>"},{"title":"./components/Annotations.html","contents":"{#each opts.annotations as d, i}\n  <div class=\"layercake-annotation\" data-id=\"{i}\" style=\"{fillStyle(d)}\">{d.text}</div>\n{/each}\n\n<style>\n  .layercake-annotation {\n    position: absolute;\n  }\n</style>\n\n<script>\nconst vals = ['top', 'right', 'bottom', 'left'];\nexport default {\n  onupdate () {\n    /* --------------------------------------------\n     * Stash this on the store so that our arrow annotation layer can hook onto these DOM elemnts\n     * only after they're created, and then on update\n     */\n    this.store.set({ annotationEls: document.querySelectorAll('.layercake-annotation') });\n  },\n  computed: {\n    fillStyle: ({ $width, $height }) => {\n      return d => {\n        let style = '';\n        vals.forEach(val => {\n          if (d[val]) {\n            style += `${val}:${d[val]};`;\n          }\n        });\n        return style;\n      };\n    }\n  }\n};\n</script>"},{"title":"./components/Arrows.html","contents":"{#if opts.annotations}\n  <g class=\"swoops\">\n    {#each opts.annotations as anno, i}\n      {#if anno.arrows}\n        {#each anno.arrows as arrow}\n          <path marker-end='url(#arrowhead)' d='{d(anno, i, arrow)}'></path>\n        {/each}\n      {/if}\n    {/each}\n  </g>\n{/if}\n\n<style>\n  .swoops {\n    position: absolute;\n    max-width: 200px;\n    line-height: 14px;\n  }\n  .swoops path {\n    fill: none;\n    stroke: #000;\n    stroke-width: 1;\n  }\n</style>\n\n<script>\nimport swoopyArrow from '../modules/swoopyArrow.js';\nimport getElPosition from '../modules/getElPosition.js';\nimport parseCssValue from '../modules/parseCssValue.js';\n\n/* --------------------------------------------\n * Some lookups to convert between x, y / width, height terminology\n * and CSS names\n */\nconst lookups = [\n  { dimension: 'width', css: 'left', position: 'x' },\n  { dimension: 'height', css: 'top', position: 'y' }\n];\n\nexport default {\n  namespace: 'svg',\n  computed: {\n    d: ({ $width, $height, opts, $annotationEls }) => {\n      return (anno, i, arrow) => {\n        if ($annotationEls) {\n          const el = $annotationEls[i];\n          // const el = document.querySelector(`.layercake-annotation[data-id=\"${i}\"]`);\n          /* --------------------------------------------\n           * Parse our attachment directives to know where to start the arrowhead\n           * measuring a bounding box based on our annotation el\n           */\n          const arrowSource = getElPosition(el);\n          const sourceCoords = arrow.source.anchor.split('-').map((d, i) => {\n            const point = d === 'middle' ? arrowSource[lookups[i].css] + (arrowSource[lookups[i].dimension] / 2) : arrowSource[d];\n            return point + (parseCssValue(arrow.source[`d${lookups[i].position}`], i, arrowSource.width, arrowSource.height));\n          });\n\n          /* --------------------------------------------\n           * Default to clockwise\n           */\n          const clockwise = typeof arrow.clockwise === 'undefined' ? true : arrow.clockwise;\n\n          /* --------------------------------------------\n           * Parse where we're drawing to\n           */\n          const targetCoords = [arrow.target.x, arrow.target.y].map((d, i) => {\n            return parseCssValue(d, i, $width, $height);\n          });\n\n          /* --------------------------------------------\n           * Create arrow path\n           */\n          const d = swoopyArrow()\n            .angle(Math.PI / 2)\n            .clockwise(clockwise)\n            .x(d => d[0])\n            .y(d => d[1])([sourceCoords, targetCoords]);\n\n          return d;\n        }\n        return '';\n      };\n    }\n  }\n};\n</script>"},{"title":"./components/DefArrowhead.html","contents":"<defs>\n  <marker id=\"arrowhead\" viewBox=\"-10 -10 20 20\" markerWidth=\"17\" markerHeight=\"17\" orient=\"auto\">\n    <path d=\"M-6,-6 L 0,0 L -6,6\" fill=\"{opts.fill || '#000'}\"/>\n  </marker>\n</defs>\n\n<script>\nexport default {\n  namespace: 'svg'\n};\n</script>"}],"modules":[{"title":"./data/groups.js","contents":"export default [\n  {\n    year: '1979',\n    value: 2\n  },\n  {\n    year: '1980',\n    value: 3\n  },\n  {\n    year: '1981',\n    value: 5\n  },\n  {\n    year: '1982',\n    value: 8\n  },\n  {\n    year: '1983',\n    value: 18\n  }\n];"}],"componentModules":[{"title":"../modules/swoopyArrow.js","contents":"/* --------------------------------------------\n *\n * Adapted from bizweekgraphics/swoopyarrows\n *\n * --------------------------------------------\n */\nexport default function swoopyArrow () {\n  let angle = Math.PI;\n  let clockwise = true;\n  let xValue = function(d) { return d[0]; };\n  let yValue = function(d) { return d[1]; };\n\n  function render(data) {\n    data = data.map(function(d, i) {\n      return [xValue.call(data, d, i), yValue.call(data, d, i)];\n    });\n\n    // get the chord length (\"height\" {h}) between points\n    const h = hypotenuse(data[1][0] - data[0][0], data[1][1] - data[0][1]);\n\n    // get the distance at which chord of height h subtends {angle} radians\n    const d = h / (2 * Math.tan(angle / 2));\n\n    // get the radius {r} of the circumscribed circle\n    const r = hypotenuse(d, h / 2);\n\n    /*\n    SECOND, compose the corresponding SVG arc.\n      read up: http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands\n      example: <path d = \"M 200,50 a 50,50 0 0,1 100,0\"/>\n                          M 200,50                          Moves pen to (200,50);\n                                   a                        draws elliptical arc;\n                                     50,50                  following a degenerate ellipse, r1 == r2 == 50;\n                                                            i.e. a circle of radius 50;\n                                           0                with no x-axis-rotation (irrelevant for circles);\n                                             0,1            with large-axis-flag=0 and sweep-flag=1 (clockwise);\n                                                 100,0      to a point +100 in x and +0 in y, i.e. (300,50).\n    */\n    const path = 'M ' + data[0][0] + ',' + data[0][1] +\n        ' a ' + r + ',' + r +\n        ' 0 0,' + (clockwise ? '1' : '0') + ' ' +\n        (data[1][0] - data[0][0]) + ',' + (data[1][1] - data[0][1]);\n\n    return path;\n  }\n\n  function hypotenuse(a, b) {\n    return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  }\n\n  render.angle = function(_) {\n    if (!arguments.length) return angle;\n    angle = Math.min(Math.max(_, 1e-6), Math.PI - 1e-6);\n    return render;\n  };\n\n  render.clockwise = function(_) {\n    if (!arguments.length) return clockwise;\n    clockwise = !!_;\n    return render;\n  };\n\n  render.x = function(_) {\n    if (!arguments.length) return xValue;\n    xValue = _;\n    return render;\n  };\n\n  render.y = function(_) {\n    if (!arguments.length) return yValue;\n    yValue = _;\n    return render;\n  };\n\n  return render;\n}"},{"title":"../modules/getElPosition.js","contents":"/* --------------------------------------------\n *\n * Constract a bounding box relative in our coordinate space\n * that we can attach arrow starting points to\n *\n * --------------------------------------------\n */\nexport default function getElPosition (el) {\n  const annotationBbox = el.getBoundingClientRect();\n  const parentBbox = el.parentNode.getBoundingClientRect();\n  const coords = {\n    top: annotationBbox.top - parentBbox.top,\n    right: annotationBbox.right - parentBbox.left,\n    bottom: annotationBbox.bottom - parentBbox.top,\n    left: annotationBbox.left - parentBbox.left,\n    width: annotationBbox.width,\n    height: annotationBbox.height\n  };\n  return coords;\n}"},{"title":"../modules/parseCssValue.js","contents":"/* --------------------------------------------\n *\n * Parse various inputs and return then as a number\n * Can be a number, which will return the input value\n * A percentage, which will take the percent of the appropriate dimentions\n * A pixel value, which will parse as a number\n *\n * --------------------------------------------\n */\nexport default function parseCssValue (d, i, width, height) {\n  if (!d) return 0;\n  if (typeof d === 'number') {\n    return d;\n  }\n  if (d.indexOf('%') > -1) {\n    return ((+d.replace('%', '')) / 100) * (i ? height : width);\n  }\n  return +d.replace('px', '');\n}"}],"dek":""}