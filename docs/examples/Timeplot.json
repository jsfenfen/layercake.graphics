{"main":{"title":"main.js","contents":"import { default as LayerCake, calcExtents } from 'layercake';\nimport { timeDay } from 'd3-time';\nimport days from './data/days.js';\nimport { csvParse } from 'd3-dsv';\nimport { scaleBand } from 'd3-scale';\nimport Scatter from './components/ScatterScaleBand.html';\nimport AxisX from './components/AxisX.html';\nimport AxisY from './components/AxisYScaleBand.html';\n\nconst r = 4;\nconst padding = 4;\n\nconst daysJson = csvParse(days, row => {\n  const parts = row.timestring.split('T');\n  const time = parts[1].replace('Z', '').split(':').map(d => +d);\n  row.seconds = time[0] * 60 * 60 + time[1] * 60 + time[2];\n  row.day = parts[0];\n  return row;\n});\n\n/* --------------------------------------------\n * Generate a range of days in between the min and max\n * in case we are missing any in our data so we can show empty days for them\n */\nconst extents = calcExtents(daysJson, [\n  { field: 'x', accessor: d => d.timestring }\n]);\n\nconst minDate = extents.x[0].split('T')[0].split('-').map(d => +d);\nconst maxDate = extents.x[1].split('T')[0].split('-').map(d => +d);\n\nconst allDays = timeDay.range(new Date(Date.UTC(minDate[0], minDate[1] - 1, minDate[2])), new Date(Date.UTC(maxDate[0], maxDate[1] - 1, maxDate[2] + 1)))\n  .map(d => d.toISOString().split('T')[0]).sort().reverse();\n\nconst myCake = new LayerCake({\n  padding: { top: 0, right: 12, bottom: 20, left: 75 },\n  x: 'seconds',\n  y: 'day',\n  xDomain: [0, 24 * 60 * 60],\n  yDomain: allDays,\n  yScale: scaleBand().paddingInner([0.05]).round(true),\n  xPadding: [padding, padding],\n  yPadding: [padding, padding],\n  data: daysJson,\n  target: document.getElementById('my-chart')\n})\n  .svgLayers([\n    { component: AxisX,\n      opts: {\n        ticks: [0, 4, 8, 12, 16, 20, 24].map(d => d * 60 * 60),\n        formatTick: d => `${Math.floor(d / 60 / 60)}:00`\n      }\n    },\n    { component: AxisY, opts: { } }\n  ])\n  .canvasLayers([\n    { component: Scatter, opts: { r, fill: 'rgba(255, 204, 0, 0.75)' } }\n  ]);\n\nmyCake.render();"},"htmlExtras":"","components":[{"title":"./components/ScatterScaleBand.html","contents":"<script>\nimport { scaleCanvas } from 'layercake';\nexport default {\n  /* --------------------------------------------\n   * Put our canvas drawing functions inside of onstate\n   * which will change on first load and whenever\n   * the store update fires\n   */\n  onstate () {\n    const { canvas, ctx, opts } = this.get();\n    const { width, height, xGet, yGet, yScale, data } = this.store.get();\n\n    /* --------------------------------------------\n     * If you were to have multiple canvas layers\n     * maybe for some artistic layering purposes\n     * put these reset functions in the first layer, not each one\n     * since they should only run once per update\n     */\n    scaleCanvas(canvas, ctx, width, height);\n    ctx.clearRect(0, 0, width, height);\n\n    /* --------------------------------------------\n     * Draw our scatterplot\n     */\n    data.forEach(d => {\n      ctx.beginPath();\n      ctx.arc(xGet(d), yGet(d) + yScale.bandwidth() / 2, opts.r, 0, 2 * Math.PI, false);\n      ctx.fillStyle = opts.fill;\n      ctx.fill();\n      if (opts.stroke) {\n        ctx.strokeStyle = opts.stroke;\n        ctx.stroke();\n      }\n    });\n  }\n};\n</script>"},{"title":"./components/AxisX.html","contents":"<g class='axis x-axis'>\n  {#each ticks as tick, i}\n    <g class='tick tick-{ tick }' transform='translate({$xScale(tick)},{$yScale.range()[0]})'>\n      {#if opts.gridlines !== false}\n        <line y1='{$height * -1}' y2='0' x1='0' x2='0'></line>\n      {/if}\n      <text y='16' text-anchor='{textAnchor(i)}'>{opts.formatTick ? opts.formatTick(tick) : tick}</text>\n    </g>\n  {/each}\n  {#if opts.baseline === true}\n    <line class=\"baseline\" y1='{$height + 0.5}' y2='{$height + 0.5}' x1='0' x2='{$width}'></line>\n  {/if}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  line,\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .baseline {\n    stroke-dasharray: 0;\n  }\n</style>\n\n<script>\nexport default {\n  namespace: 'svg',\n  computed: {\n    ticks: ({ $xScale, opts }) => {\n      return opts.ticks || $xScale.ticks(opts.tickNumber);\n    },\n    textAnchor: ({ ticks, opts }) => {\n      return function (i) {\n        if (opts.snapTicks === true) {\n          if (i === 0) {\n            return 'start';\n          }\n          if (i === ticks.length - 1) {\n            return 'end';\n          }\n        }\n        return 'middle';\n      };\n    }\n  }\n};\n</script>"},{"title":"./components/AxisYScaleBand.html","contents":"<g class='axis y-axis'>\n  {#each $yScale.domain() as tick}\n    <g class='tick tick-{ tick }' transform='translate({$xScale.range()[0]}, {$yScale(tick)})'>\n      {#if opts.gridlines !== false}\n        <line x2='100%' y1=\"{halfBandwidth}\" y2=\"{halfBandwidth}\"></line>\n      {/if}\n      <text y='{4 + (halfBandwidth)}' x=\"-5\">{opts.formatTick ? opts.formatTick(tick) : tick}</text>\n    </g>\n  {/each}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .tick.tick-0 line {\n    stroke-dasharray: 0;\n  }\n\n  .y-axis .tick text {\n    text-anchor: end;\n  }\n</style>\n\n<script>\nexport default {\n  namespace: 'svg',\n  computed: {\n    halfBandwidth: ({ $yScale }) => {\n      return $yScale.bandwidth() / 2;\n    }\n  }\n};\n</script>"}],"modules":[{"title":"./data/days.js","contents":"export default `timestring\n2018-07-22T22:25:55Z\n2018-07-22T19:35:29Z\n2018-07-22T18:54:42Z\n2018-07-22T02:05:59Z\n2018-07-22T00:55:02Z\n2018-07-22T00:53:00Z\n2018-07-22T23:32:37Z\n2018-07-22T17:52:55Z\n2018-07-22T17:52:01Z\n2018-07-22T17:32:21Z\n2018-07-22T16:38:22Z\n2018-07-22T16:38:20Z\n2018-07-22T21:07:28Z\n2018-07-22T01:36:47Z\n2018-07-22T01:00:04Z\n2018-07-22T20:15:35Z\n2018-07-23T03:05:05Z\n2018-07-23T02:56:18Z\n2018-07-23T02:11:53Z\n2018-07-23T02:08:49Z\n2018-07-23T02:02:14Z\n2018-07-23T04:13:29Z\n2018-07-23T03:24:58Z\n2018-07-23T03:23:55Z\n2018-07-23T03:22:02Z\n2018-07-23T18:37:05Z\n2018-07-23T01:34:48Z\n2018-07-23T01:11:38Z\n2018-07-23T01:02:25Z\n2018-07-23T23:32:07Z\n2018-07-23T18:26:04Z\n2018-07-24T18:25:35Z\n2018-07-24T02:56:28Z\n2018-07-24T16:33:57Z\n2018-07-24T15:52:16Z\n2018-07-24T20:31:12Z\n2018-07-24T20:27:11Z\n2018-07-24T14:17:18Z\n2018-07-24T03:49:28Z\n2018-07-24T03:42:33Z\n2018-07-24T03:20:45Z\n2018-07-24T01:47:25Z\n2018-07-24T01:26:16Z\n2018-07-24T01:16:55Z\n2018-07-25T00:50:15Z\n2018-07-25T19:16:21Z\n2018-07-25T02:38:15Z\n2018-07-25T01:03:55Z\n2018-07-25T01:00:55Z\n2018-07-25T00:59:31Z\n2018-07-25T19:06:36Z\n2018-07-25T19:03:18Z\n2018-07-25T01:05:50Z\n2018-07-25T23:43:32Z\n2018-07-25T17:39:53Z\n2018-07-25T17:37:15Z\n2018-07-25T15:50:12Z\n2018-07-25T03:47:16Z\n2018-07-25T03:06:21Z\n2018-07-25T02:59:34Z\n2018-07-25T20:53:53Z\n2018-07-25T01:37:58Z\n2018-07-25T01:32:23Z\n2018-07-25T01:30:09Z\n2018-07-25T17:03:39Z\n2018-07-25T16:00:39Z\n2018-07-25T15:59:44Z\n2018-07-25T22:29:55Z\n2018-07-25T02:59:41Z\n2018-07-25T02:58:36Z\n2018-07-25T02:56:41Z\n2018-07-25T02:21:56Z\n2018-07-25T02:20:27Z\n2018-07-25T02:15:25Z\n2018-07-25T02:22:38Z\n2018-07-25T02:19:25Z\n2018-07-25T22:48:50Z\n2018-07-25T06:52:20Z\n2018-07-25T06:45:09Z\n2018-07-25T21:18:11Z\n2018-07-25T17:35:37Z\n2018-07-25T01:52:56Z\n2018-07-25T01:07:36Z\n2018-07-25T01:05:37Z\n2018-07-25T01:05:27Z\n2018-07-25T17:24:44Z\n2018-07-25T15:53:26Z\n2018-07-25T15:32:59Z\n2018-07-25T17:33:38Z\n2018-07-25T15:28:30Z\n2018-07-25T15:16:40Z\n2018-07-28T15:07:48Z\n2018-07-28T13:56:38Z\n2018-07-28T04:46:00Z\n2018-07-28T04:19:46Z\n2018-07-28T04:18:59Z\n2018-07-28T04:14:41Z\n2018-07-28T03:54:01Z\n2018-07-28T03:53:10Z\n2018-07-28T02:28:02Z\n2018-07-28T17:41:43Z\n2018-07-28T04:42:10Z\n2018-07-28T04:40:23Z\n2018-07-28T04:40:10Z\n2018-07-28T01:31:38Z\n2018-07-28T00:23:02Z\n2018-07-28T18:17:10Z\n2018-07-28T18:08:21Z\n2018-07-28T15:29:46Z\n2018-07-28T15:15:33Z\n2018-07-28T04:54:39Z\n2018-07-28T04:27:48Z\n2018-07-28T04:24:37Z\n2018-07-28T04:08:45Z\n2018-07-28T03:53:50Z\n2018-07-28T03:42:23Z\n2018-07-28T19:03:27Z\n2018-07-28T00:32:39Z\n2018-07-28T00:32:32Z\n2018-07-28T02:57:20Z\n2018-07-28T02:54:40Z\n2018-07-28T04:28:23Z\n2018-07-28T02:19:41Z\n2018-07-28T00:50:51Z\n2018-07-28T00:40:52Z\n2018-07-28T21:54:06Z\n2018-07-28T21:53:09Z\n2018-07-28T19:09:30Z\n2018-07-28T18:55:04Z\n2018-07-28T18:51:44Z\n2018-07-28T17:24:28Z\n2018-07-28T02:31:18Z\n2018-07-28T04:20:20Z\n2018-07-28T04:19:13Z\n2018-07-28T04:16:31Z`;"}],"componentModules":[],"dek":"A scatter plot with an `scaleBand` for the y-scale to bucket them by day. The only real fancy part of this plot is modifying the input data to be in \"seconds since start of day\" and generating the `yDomain` as *every* day between the min and max values, not just days for which we have values. This lets us see days in between that have no data.\n"}